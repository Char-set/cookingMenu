## 平时有关注前端的内存处理吗？

### 1. 你了解js中的内存管理吗？什么情况会导致内存泄露呢？

1. 内存的生命周期

内存分配：声明变量 函数 对象的时候
内存使用：读写内存，使用变量 函数等
内存回收：使用完毕，有垃圾回收机制自动回收不再使用的内存

2. js中的内存分配

```js
const n = 123;
const s = 'str'
```

3. js的内存使用

```js
const a = 10;

console.log(a); // 使用
```

4. js中的垃圾回收机制

垃圾回收的算法主要依赖于引用的概念

4.1 引用计数法

看一个对象是否有指向他的饮用，如果没有其他对象指向他了，说明当前这个对象不再被需要了。

循环引用

如果两个对象相互引用，尽管他们已不再被使用，但是引用计数无法识别，导致内存泄漏

4.2 标记清除法

将`"不再使用的对象"`定义为`"无法到达的对象"`

从根据js的全局对象出发，定时扫描内存中的对象，凡是无法从根部到达的对象，就会被标记为不再使用，稍后进行回收

* 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记
* 从根部出发能够触及到的对象标记删除
* 剩下的还有标记的变量被视为准备删除的变量
* 垃圾收集器销毁带有标记的值 回收内存

5. 常见的内存泄漏

5.1 全局变量

```js
function foo() {
    bar1 = 'aaaa';
    this.bar2 = 'aaaa';
}

foo();
```

5.2 未被清理的定时器和回调函数

setInterval
setTimeout


5.3 闭包

5.4 dom引用

```js
var elements = {
    image: document.getElementById('iiii')
}
```

6. 怎么避免？

尽量减少全局变量
使用完数据后，及时解除引用
避免死循环等持续执行的操作

### 实现一个sizeOf函数